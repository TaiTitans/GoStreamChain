package ethclient

import (
	"context"
	"fmt"
	"log"

	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"
	"github.com/ethereum/go-ethereum/rpc"
	"math/big"
	"strings"
)

type EthClient struct {
	RPCClient *rpc.Client
	EthClient *ethclient.Client
	Client    *rpc.Client
}

func NewEthClient(rpcURL string) (*EthClient, error) {
	client, err := rpc.Dial(rpcURL)
	if err != nil {
		return nil, err
	}

	ethClient := ethclient.NewClient(client)

	return &EthClient{
		RPCClient: client,
		EthClient: ethClient,
	}, nil
}

func (ec *EthClient) JoinRoom(privateKey string, contractAddress string, roomID string, clientID string) {
	// Get the sender's address from the private key
	key, err := crypto.HexToECDSA(privateKey)
	if err != nil {
		log.Fatal(err)
	}

	_ = crypto.PubkeyToAddress(key.PublicKey) // Ignore the unused variable

	// ABI of the contract, generated by `abigen`
	contractABI, err := abi.JSON(strings.NewReader(`[ABI_JSON_HERE]`))
	if err != nil {
		log.Fatal(err)
	}

	// Create the data for the transaction (method joinRoom)
	data, err := contractABI.Pack("joinRoom", roomID, clientID)
	if err != nil {
		log.Fatal(err)
	}

	// Construct the transaction
	tx := types.NewTransaction(
		0,                                    // Nonce (Set this to the next valid nonce in a real application)
		common.HexToAddress(contractAddress), // Contract address
		nil,                                  // Value, for non-zero transfers
		21000,                                // Gas limit (set to a default value or adjust according to your contract)
		big.NewInt(20000000000),              // Gas price (example value, adjust as needed)
		data,
	)

	chainID, err := ec.EthClient.NetworkID(context.Background())

	// Sign the transaction
	if chainID == nil {
		chainID, err = ec.EthClient.NetworkID(context.Background())
		if err != nil {
			log.Fatal(err)
		}
	}

	signedTx, err := types.SignTx(tx, types.NewEIP155Signer(chainID), key)
	if err != nil {
		log.Fatal(err)
	}

	// Send the transaction
	err = ec.EthClient.SendTransaction(context.Background(), signedTx)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Transaction Sent:", signedTx.Hash().Hex())
}
